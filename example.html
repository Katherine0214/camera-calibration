<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>Camera Calibration Toolbox for Matlab</TITLE>
<!-- Changed by: Jean-Yves Bouguet, 24-Dec-1999 -->
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (X11; U; SunOS 4.1.3_U1 sun4m) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000CC" VLINK="#0000FF" ALINK="#FF0000">
<a name="top">
<CENTER>
<BLOCKQUOTE>&nbsp;
<TABLE CELLSPACING=0 CELLPADDING=5 WIDTH="90%" BGCOLOR="#6A9BED" NOSAVE >
<TR NOSAVE>
<TD NOSAVE>
<CENTER><A NAME="links"></A><I><FONT COLOR="#000000"><FONT SIZE=+4> Camera Calibration Toolbox for Matlab</FONT></FONT></I></CENTER>
</TD>
</TR>
</TABLE>
&nbsp;</BLOCKQUOTE>
</CENTER>


<H1><IMG SRC="../gifs/starroll.gif" width="20" height="18"> First calibration example - Corner extraction, calibration, additional tools </H1>

This section takes you through a complete calibration example based on a total of 20 (and 25) images of a planar checkerboard.<BR>
This example lets you learn how to use all the features of the toolbox: loading
calibration images, extracting image corners, running the main
calibration engine, displaying the results, controlling accuracies,
adding and suppressing images, undistorting images, exporting calibration data to
different formats...  This example is
highly recommended for someone who is just starting using the toolbox.


<BR><BR>


<ul>

<li>Download the calibration images all at once <a href="calib_example.zip">calib_example.zip (4461Kb zipped)</a> or <a href="calib_example/index.html">one by one</a>, and store the 20 images into a seperate folder named
<b>calib_example</b>.
</li>

<BR><BR>

<center><a href="calib_example/index.html"><IMG SRC="../gifs/list_images.gif" width="644" height="452"></a></center>

<BR>

<li>From within matlab, go to the example folder <b>calib_example</b> containing the images.

</li>

<BR>
<BR>

<li><b><font size=+1>Reading the images:</font></b> <BR><BR> Click on the <b>Image names</b> button in the <b>Camera calibration tool</b> window.
Enter the basename of the calibration images (<b>Image</b>) and the image format (<b>tif</b>).<BR>
All the images (the 20 of them) are then loaded in memory (through the command <b>Read images</b> that is automatically executed) in the variables <b>I_1</b>, <b>I_2</b> ,..., <b>I_20</b>. The number of images is stored in the variable <B>n_ima (=20 here)</B>.<BR>
The matlab window should look like this: <BR><BR>

<align="left"><IMG SRC="../gifs/image_name.gif"></align>

<BR><BR>
The complete set of images is also shown in thumbnail format (this images can always be regenerated by running <b>mosaic</b>):
<BR><BR>
<center><IMG SRC="../gifs/image_name2.gif" ></center>
<BR><BR>

</LI>

If the <B>OUT OF MEMORY</B> error message occurred during image reading, that means that your computer does not have enough RAM to hold the entire set of images in local memory. This can easily happen of you are running the toolbox on a 128MB or less laptop for example.
In this case, you can directly switch to the memory efficient version of the toolbox by running <B>calib_gui</B> and selecting the memory efficient mode of operation. The remaining steps of calibration (grid corner extraction and calibration) are exactly the same. Note that in memory efficient mode, the thumbnail image is not displayed since the calibration images are not loaded all at once.
<BR><BR><BR>



<li> <b><font size=+1>Extract the grid corners:</font></b> <BR>
<BR>
Click on the <b>Extract grid corners</b> button in the <b>Camera calibration tool</b> window.
<BR><BR>


<align="left"><IMG SRC="../gifs/corner0.gif"></align>



<BR><BR> Press "enter" (with an empty argument) to select all the images
(otherwise, you would enter a list of image indices like <b>[2 5 8 10
12]</b> to extract corners of a subset of images). Then, select the
default window size of the corner finder: <b>wintx=winty=5</b> by
pressing "enter" with empty arguments to the <b>wintx</b> and
<b>winty</b> question. This leads to a effective window of size 11x11
pixels.  <BR><BR>


<align="left"><IMG SRC="../gifs/corner_sc1.gif"></align>



<BR><BR>
The corner extraction engine includes an automatic mechanism for counting the number of squares in the grid. This tool is specially convenient when working with a large number of images since the user does not have to manually enter the number of squares in both x and y directions of the pattern.
On some very rare occasions however, this code may not predict the right number of squares. This would typically happen when calibrating lenses with extreme distortions. At this point in the corner extraction procedure, the program gives the option to the user to disable the automatic square counting code. In that special mode, the user would be prompted for the square count for every image. In this present example, it is perfectly appropriate to keep working in the default mode (i.e. with automatic square counting activated), and therefore, simply press "enter" with an empty argument. (<B>NOTE:</B> it is generally recommended to first use the corner extraction code in this default mode, and then, if need be, re-process the few images with "problems")

<BR><BR>
<align="left"><IMG SRC="../gifs/corner_sc2.gif"></align>
<BR><BR>

The first calibration image is then shown on Figure 2: 

<BR>
<BR>

<center><IMG SRC="../gifs/corner2.gif"></center>

<BR><BR>

Click on the four extreme corners on the rectangular checkerboard
pattern. The clicking locations are shown on the four following
figures (<B>WARNING:</B> try to click accurately on the four corners,
at most 5 pixels away from the corners. Otherwise some of the corners might be missed by the detector).
<BR><BR> <FONT color="#FF0000" size=+1>Ordering rule for clicking:</FONT> The first clicked point is selected to be associated to the origin point of the reference frame attached to the grid.
The other three points of the rectangular grid can be clicked in any order. This first-click rule is especially important if you need to calibrate externally multiple cameras (i.e. compute the relative positions of several cameras in space). When dealing with multiple cameras, the same grid pattern reference frame needs to be consistently selected for the different camera images (i.e. grid points need to correspond across the different camera views). For example, it is a requirement to run the stereo calibration toolbox <B>stereo_gui.m</B> (try <B>help stereo_gui</B> and visit the <A href="example5.html">fifth calibration example page</A> for more information).<!-- If your goal is simply to calibrate a single camera internally, then the choice of reference frame on the grid pattern can be done totally arbitrarily. -->

<BR><BR>


<center> <IMG SRC="../gifs/corner3456.gif"> </center>

<BR><BR>
The boundary of the calibration grid is then shown on Figure 2:
<BR><BR>

<center><IMG SRC="../gifs/corner7.gif"></center>

<BR><BR>
Enter the sizes <b>dX</b> and <b>dY</b> in X and Y of each square in the grid (in this case, <b>dX=dY=30mm</b>=default values):
<BR><BR>

<align="left"><IMG SRC="../gifs/corner8.gif"></align>

<BR><BR>
Note that you could have just pressed "enter" with an empty argument to select the default values.
The program automatically counts the number of squares in both dimensions, and shows the predicted grid corners in absence of distortion:
<BR><BR>

<center><IMG SRC="../gifs/corner9.gif"></center>

<BR>

<align="left"><IMG SRC="../gifs/corner92.gif"></align>


<BR><BR>
If the predicted corners are close to the real image corners, then the following step may be skipped (if there is not much image distortion).
This is the case in that present image: the predicted corners are close enough to the real image corners. Therefore, it is not necessary to "help" the software to detect the image corners by entering a guess
for radial distortion coefficient. Press "enter", and the corners are automatically extracted using those positions as initial guess.
<BR><BR>

<align="left"><IMG SRC="../gifs/corner12.gif" ></align>

<BR><BR>
The image corners are then automatically extracted, and displayed on figure 3 (the blue squares around the corner points show the limits 
of the corner finder window):
<BR><BR>

<center><IMG SRC="../gifs/corner13.gif"></center>

<BR><BR>
The corners are extracted to an accuracy of about 0.1 pixel. <BR>
Follow the same procedure for the 2<SUP>nd</SUP>, 3<SUP>rd</SUP>, ... , 14<SUP>th</SUP> images. For example, here are the detected corners of image 2, 3, 4, 5, 6 and 7:
<BR><BR>

<center> <IMG SRC="../gifs/corner14_15.gif" > </center>


<BR><BR>
Observe the square dimensions <B>dX</B>, <B>dY</B> are always kept to their original values (30mm).<BR>
Sometimes, the predicted corners are not quite close enough to the real image corners to allow for an effective corner extraction.
In that case, it is necessary to refine the predicted corners by entering a guess for lens distortion coefficient.
This situation occurs at image 15. On that image, the predicted corners are:
<BR><BR>

<center><IMG SRC="../gifs/corner18.gif"></center>

<BR><BR>
Observe that some of the predicted corners within the grid are far enough from the real grid corners to result into wrong extractions. The cause: image distortion. In order to help the system make a better guess of the corner locations, the user is free to manually input a guess for the first order lens distortion coefficient <B>kc</B> (to be precise, it is the first entry of the full distortion coefficient vector <B>kc</B> described at this <A href="parameters.html">page</a>). In order to input a guess for the lens distortion coefficient, enter a non-empty string to the question <b>Need of an initial guess for distortion?</b> (for example <B>1</B>). Enter then a distortion coefficient of <b>kc=-0.3</b> (in practice, this number is typically between -1 and 1).
<BR><BR>

<align="left"><IMG SRC="../gifs/corner19.gif" ></align>

<BR><BR>
According to this distortion, the new predicted corner locations are:
<BR><BR>

<center><IMG SRC="../gifs/corner20.gif"></center>


<BR><BR>
If the new predicted corners are close enough to the real image corners (this is the case here), input any non-empty string (such as <b>1</b>) to the question <b>Satisfied with distortion?</b>. The subpixel corner locations are then computed using the new predicted locations (with image distortion) as initial guesses:
<BR><BR>

<align="left"><IMG SRC="../gifs/corner12.gif"></align>

<BR><BR>
If we had not been satisfied, we would have entered an empty-string to the question <b>Satisfied with distortion?</b> (by directly pressing "enter"), and then tried a new distortion coefficient <b>kc</b>. You may repeat this process as many times as you want until satisfied with the prediction (<B>side note:</B> the values of distortion used at that stage are only used to help corner extraction and will not affect at all the next main calibration step. In other words, these values are neither used as final distortion coefficients, nor used as initial guesses for the true distortion coefficients estimated through the calibration optimization stage). <BR><BR>
The final detected corners are shown on Figure 3:
<BR><BR>

<center><IMG SRC="../gifs/corner22.gif" ></center>

<BR><BR>
Repeat the same procedure on the remaining 5 images (16 to 20). On these images however, do not use the predicted distortion option, even if the extracted corners are not quite right. In the next steps, we will correct them (in this example, we could have not used this option for image 15, but that was quite useful for illustration).
<BR><BR>
After corner extraction, the matlab data file <B>calib_data.mat</B> is automatically generated. This file contains all the information gathered throughout the corner extraction stage (image coordinates, corresponding 3D grid coordinates, grid sizes, ...). This file is only created in case of emergency when for example matlab is abruptly terminated before saving. Loading this file would prevent you from having to click again on the images.
<BR><BR>
During your own calibrations, when there is a large amount of distortion in the image, the program may not be able to automatically count the number of squares in the grid.
In that case, the number of squares in both X and Y directions have to be entered manually.
This should not occur in this present example.
<BR><BR>
Another problem may arise when performing your own calibrations. If the lens distortions are really too severe (for fisheye lenses for example), the simple guiding tool based on a single distortion coefficient <B>kc</B> may not be sufficient to provide good enough initial guesses for the corner locations. For those few difficult cases, a script program is included in the toolbox that allows for a completely manual corner extraction (i.e. one click per corner). The script file is called <B>manual_corner_extraction.m</B> (in memory efficient mode, you should use <B>manual_corner_extraction_no_read.m</B> instead) and should be executed AFTER the traditional corner extaction code (the script relies on data that were computed by the traditional corner extraction code -square count, grid size, order of points, ...- even if the corners themselves were wrongly detected). Obviously, this method for corner extraction could be extremely time consuming when applied on a lot of images. It therefore recommended to use it as a last resort when everything else has failed. Most users should never have to worry about this, and it will not happen in this present calibration example.
<BR><BR>


</li>


<li><b><font size=+1>Main Calibration step:</font></b> <BR><BR> After
corner extraction, click on the button <b>Calibration</b> of the
<b>Camera calibration tool</b> to run the main camera calibration
procedure.<BR> Calibration is done in two steps: first initialization,
and then nonlinear optimization.<BR> The initialization step computes
a closed-form solution for the calibration parameters based not
including any lens distortion (program name:
<b>init_calib_param.m</b>).<BR> The non-linear optimization step
minimizes the total reprojection error (in the least squares sense)
over all the calibration parameters (9 DOF for intrinsic: focal,
principal point, distortion coefficients, and 6*20 DOF extrinsic =>
129 parameters). For a complete description of the calibration
parameters, click on that <a href="parameters.html">link</a>.  The
optimization is done by iterative gradient descent with an explicit
(closed-form) computation of the Jacobian matrix (program name:
<b>go_calib_optim.m</b>).  <BR><BR>

<align="left"><IMG SRC="../gifs/gradient1.gif"></align>

<BR><BR>The Calibration parameters are stored in a number of
variables. For a complete description of them, visit this <A href="parameters.html">page</A>. Notice
that the skew coefficient <b>alpha_c</b> and the 6th order radial distortion coefficient (the last entry of <B>kc</B>) have not been estimated (this
is the default mode). Therefore, the angle between the x and y pixel
axes is 90 degrees. In most practical situations, this is a very good
assumption. However, later on, a way of introducing the skew
coefficient <b>alpha_c</b> in the optimization will be presented.

<!--
<BR><BR>

<font color="#ff0000"><b>Latest update (Feb 9th, 2000):</b> Five
distortion coefficients are now estimated (instead of four), including
a radial distortion model up to the 6th degree. Check that <a
href="parameters.html">link</a> for a description of the
current intrinsic camera model.</font>
-->

<BR><BR> Observe that only 11 gradient descent iterations are required
in order to reach the minimum. This means only 11 evaluations of the
reprojection function + Jacobian computation and inversion. The reason
for that fast convergence is the quality of the initial guess for the
parameters computed by the initialization procedure. <BR> For now, ignore the recommendation of the system to reduce the distortion model. The reprojection error is still too large to make a judgement on the complexity of the model. This is mainly because some of the grid corners were not very precisely extracted for a number of images. <BR>Click on
<b>Reproject on images</b> in the <b>Camera calibration tool</b> to
show the reprojections of the grids onto the original images.  These
projections are computed based on the current intrinsic and extrinsic
parameters. Input an empty string (just press "enter") to the question
<b>Number(s) of image(s) to show ([] = all images)</b> to indicate
that you want to show all the images: <BR><BR>

<align="left"><IMG SRC="../gifs/reproject0.gif"></align>


<BR><BR>
The following figures shows the first four images with the detected corners (red crosses) and the reprojected grid corners (circles).
<BR><BR>

<center><IMG SRC="../gifs/reproject1_4.gif" ></center>
<BR><BR>
<align="left"><IMG SRC="../gifs/proj_error0.gif"></align>


<BR><BR>
The reprojection error is also shown in the form of color-coded crosses:
<BR><BR>

<center><IMG SRC="../gifs/proj_error.gif"></center>

<BR><BR>In order to exit the error analysis tool, right-click on anywhere on the figure (you will understand later the use of this option).<BR>
Click on <b>Show Extrinsic</b> in the <b>Camera calibration tool</b>.
The extrinsic parameters (relative positions of the grids with respect to the camera) are then shown in a form of a 3D plot:
<BR><BR>

<center><IMG SRC="../gifs/extrinsic.gif" ></center>


<BR><BR> On this figure, the frame
<b>(O<sub>c</sub>,X<sub>c</sub>,Y<sub>c</sub>,Z<sub>c</sub>)</b> is
the camera reference frame. The red pyramid corresponds to the
effective field of view of the camera defined by the image plane.
To switch from a "camera-centered" view to a "world-centered" view, just click on the <B>Switch to world-centered view</B> button located at the bottom-left corner of the figure. 
<BR><BR>


<center><IMG SRC="../gifs/extrinsic2.gif" ></center>


<BR><BR>On this new figure, every camera position and orientation is represented by a green pyramid. Another click on the <B>Switch to camera-centered view</B> button turns the figure back to the "camera-centered" plot.<BR><BR>
Looking back at the error plot, notice that the reprojection error is very large across a
large number of figures.  The reason for that is that we have not done
a very careful job at extracting the corners on some highly distorted
images (a better job could have been done by using the predicted
distortion option). Nevertheless, we can correct for that now by
recomputing the image corners on all images automatically. Here is the
way it is going to be done: press on the <b>Recomp. corners</b> button
in the main <b>Camera calibration tool</b> and select once again a
corner finder window size of <b>wintx = winty = 5</b> (the default values):

<BR><BR>
<align="left"><IMG SRC="../gifs/re_corner_large1.gif" ></align>
<BR><BR>

To the question <b>Number(s) of image(s) to process ([] = all
     images)</b> press "enter" with an empty argument to recompute the
     corners on all the images. Enter then the mode of extraction: the
     automatic mode (auto) uses the re-projected grid as initial guess
     locations for the corner, the manual mode lets the user extract
     the corners manually (the traditional corner extraction
     method). In the present case, the reprojected grid points are
     very close to the actual image corners. Therefore, we select the
     automatic mode: press "enter" with an empty string. The corners
     on all images are then recomputed. your matlab window should look
     like:


<BR><BR>
<align="left"><IMG SRC="../gifs/re_corner_large2.gif"></align>
<BR><BR>

Run then another calibration optimization by clicking on <b>Calibration</b>:
<BR><BR>

<align="left"><IMG SRC="../gifs/gradient2.gif"></align>




<BR><BR> Observe that only six iterations were necessary for
convergence, and no initialization step was performed (the
optimization started from the previous calibration result).  The two
values <b>0.12668</b> and <b>0.12604</b> are the standard deviation of
the reprojection error (in pixel) in both x and y directions
respectively. Observe that the uncertainties on the calibration parameters are also estimated. The numerical values are approximately three times the standard deviations.<BR> After optimization, click on <b>Save</b> to save
the calibration results (intrinsic and extrinsic) in the matlab file
<B>Calib_Results.mat</B> <BR><BR>

<align="left"><IMG SRC="../gifs/saving.gif" width="435" height="44"></align>


<BR><BR>
For a complete description of the calibration parameters, click on that <a href="parameters.html">link</a>. <BR>
Once again, click on <b>Reproject on images</b> to reproject the grids onto the original calibration images. The four first images look like:
<BR><BR>

<center><IMG SRC="../gifs/reproject1_4.gif"></center>

<BR><BR>
Click on <B>Analyse error</B> to view the new reprojection error (observe that the error is much smaller than before):
<BR><BR>

<center><IMG SRC="../gifs/re_proj_error.gif"></center>

<BR><BR>
After right-clicking on the error figure (to exit the error-analysis tool), click on <b>Show Extrinsic</b> to show the new 3D positions of the grids with respect to the camera:
<BR><BR>

<center><IMG SRC="../gifs/re_extrinsic.gif"></center>

<BR><BR>A simple click on the <b>Switch to world-centered view</B> button changes the figure to this:
<BR><BR>

<center><IMG SRC="../gifs/re_extrinsic2.gif"></center>


<BR><BR>
The tool <b>Analyse error</b> allows you to inspect which points correspond to large errors.
Click on <b>Analyse error</b> and click on the figure region that is shown here (upper-right figure corner):

<BR><BR>
<center><IMG SRC="../gifs/error_analyse1.gif"></center>
<BR><BR>

After clicking, the following information appears in the main Matlab window:

<BR><BR>
<align="left"><IMG SRC="../gifs/error_analyse2.gif"></align>
<BR><BR>


This means that the corresponding point is on image 18, at the grid coordinate (0,0)  in the calibration grid (at the origin of the pattern). The following image shows a close up of that point on the calibration image (before, exit the error inspection tool by clicking on the right mouse button anywhere within the figure):
<BR><BR>

<center><IMG SRC="../gifs/error_analyse3.gif"></center>


<BR><BR>
The error inspection tool is very useful in cases where the corners have been badly extracted on one or several images. In such a case, the user can recompute the corners of the specific images using a different window size (larger or smaller). 
<BR><BR>
For example, let us recompute the image corners using a window size (<b>wintx=winty=9</b>) for all 20 images except for images 20  (use <b>wintx=winty=5</b>), images 5, 7, 8, 19 (use <b>wintx=winty=7</b>), and images 18 (use <b>wintx=winty=8</b>). The  extraction of the corners should be performed with three calls of <b>Recomp. corners</b>. At the first call of  <b>Recomp. corners</b>, select 
<b>wintx=winty=9</b>, choose to process images 1, 2, 3, 4, 6, 9, 10, 11, 12, 13, 14, 15, 16 and 17, and select the automatic mode (the reprojections are already very close to the actual image corners):

<BR><BR>
<align="left"><IMG SRC="../gifs/re_corner1.gif"></align>
<BR><BR>

At the second call of  <b>Recomp. corners</b>,  select 
<b>wintx=winty=8</b>, choose to process image 18 and select once again the automatic mode:


<BR><BR>
<align="left"><IMG SRC="../gifs/re_corner2.gif"></align>
<BR><BR>


At the third call of  <b>Recomp. corners</b>,  select 
<b>wintx=winty=7</b>, choose to process images 5, 7, 8 and 19 and select once again the automatic mode:

<BR><BR>
<align="left"><IMG SRC="../gifs/re_corner3.gif"></align>
<BR><BR>

Re-calibrate by clicking on <b>Calibration</b>:

<BR><BR>


<align="left"><IMG SRC="../gifs/re_optim1.gif" ></align>


<BR><BR>
Observe that the reprojection error (<b>0.11689</b>,<b>0.11500</b>) is slightly smaller than the previous one. In addition, observe that the uncertainties on the calibration parameters are also smaller. Inspect the error by clicking on <b>Analyse error</b>:

<BR><BR>
<center><IMG SRC="../gifs/error_analyse4.gif"></center>
<BR><BR>

Let us look at the previous point of interest on image 18, at the grid coordinate (0,0) in the calibration grid. For that, click on <b>Reproject on images</b> and select to show image 18 only (of course, before that, you must exit the error inspection tool by right-cliking within the window):

<BR><BR>

<align="left"><IMG SRC="../gifs/re_corner4.gif"></align>

<BR><BR>



A close view at the point of interest (on image 18) shows a smaller reprojection error:

<BR><BR>

<center><IMG SRC="../gifs/proj_error2.gif"></center>

<BR><BR>



Click once again on <b>Save</b> to save the calibration results (intrinsic and extrinsic) in the matlab file <B>Calib_Results.mat</B>
<BR><BR>

<align="left"><IMG SRC="../gifs/saving2.gif"></align>

<BR><BR>

Observe that the previous calibration result file was copied under <B>Calib_Results_old0.mat</B> (just in case you want to use it later on).


<BR><BR>
Download now the five additional images <a href="Image21.tif">Image21.tif</a>,
<a href="Image22.tif">Image22.tif</a>, <a href="Image23.tif">Image23.tif</a>, <a href="Image24.tif">Image24.tif</a> and <a href="Image25.tif">Image25.tif</a> and
re-calibrate the camera using the complete set of 25 images without recomputing everything
from scratch. <BR>
After saving the five additional images in the current directory, click on <b>Read images</b> to read the complete new set of images:

<BR><BR>
<align="left"><IMG SRC="../gifs/read_25.gif"></align>
<BR><BR>

To show a thumbnail image of all calibration images, run <B>mosaic</B> (if you are running in memory efficient mode, run <B>mosaic_no_read</B> instead).
<BR><BR>

<center><IMG SRC="../gifs/read_25_2.gif"></center>

<BR><BR>


Click on <b>Extract grid corners</b> to extract the corners on the five new images, with default window sizes <b>wintx=winty=5</b>:


<BR><BR>
<align="left"><IMG SRC="../gifs/corner_25.gif"></align>

<BR><BR>

And go on with the traditional corner extraction on the five images.
Afterwards, run another optimization by clicking on <b>Calibration</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/re_optim2.gif"></align>
<BR><BR>

Next, recompute the image corners of the four last images using different window sizes. Use <b>wintx=winty=9</b> for images 22 and 24, use <b>wintx=winty=8</b> for image 23, and use <b>wintx=winty=6</b> for image 25.
Follow the same procedure as previously presented (three calls of <b>Recomp. corners</b> should be enough). After recomputation, run <b>Calibration</b> once again:

<BR><BR>
<align="left"><IMG SRC="../gifs/re_optim3.gif" ></align>
<BR><BR>


Click once again on <b>Save</b> to save the calibration results (intrinsic and extrinsic) in the matlab file <B>Calib_Results.mat</B>
<BR><BR>

<align="left"><IMG SRC="../gifs/saving3.gif" width="570" height="92"></align>

<BR><BR>

As an exercise, recalibrate based on all images, except images 16, 18,
19, 24 and 25 (i.e. calibrate on a new set of 20 images). <BR> Click
on <b>Add/Suppress images</b>.  <BR><BR>

<align="left"><IMG SRC="../gifs/suppress2.gif"></align>

<BR><BR>
Enter the list of images to suppress (<b>[16 18 19 24 25]</b>): 
<BR><BR>

<align="left"><IMG SRC="../gifs/suppress3.gif"></align>

<BR><BR>
Click on <b>Calibration</b> to recalibrate:
<BR><BR>


<align="left"><IMG SRC="../gifs/suppress4.gif" ></align>

<BR><BR> It is up to user to use the function <b>Add/Suppress
images</b> to activate or de-activate images. In effect, this function
simply updates the binary vector <b>active_images</b> setting zeros to
inactive images, and ones to active images.<BR> Next, load the old
calibration results previously saved in <b>Calib_Results.mat</b> by
clicking on <b>Load</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/loading.gif"></align>
<BR><BR>

The setup is now back to what it was before supressing 5 images 16, 18,
19, 24 and 25. Let us now run a calibration by including the skew factor <b>alpha_c</b> describing the angle between the x and y pixel axes. For that, set the variable <b>est_alpha</b> to one (at the matlab prompt). As an exercise, let us fit the radial distortion model up to the 6th order (up to now, it was up to the 4th order, with tangential distortion). For that, set the last entry of the vector <B>est_dist</B> to one:


<BR><BR>
<align="left"><IMG SRC="../gifs/skew1.gif"></align>
<BR><BR>


Then, run a new calibration by clicking on <b>Calibration</b>:


<BR><BR>
<align="left"><IMG SRC="../gifs/skew2.gif" ></align>
<BR><BR>

Observe that after optimization, the skew coefficient is very close to
zero (<b>alpha_c = 0.00042</b>). This leads to an angle between x and
y pixel axes very close to 90 degrees (89.976 degrees). This justifies
the previous assumption of rectangular pixels (<b>alpha_c = 0</b>). In addition, notice that the uncertainty on the 6th order radial distortion coefficient is very large (the uncertainty is much larger than the absolute value of the coefficient). In this case, it is preferable to disable its estimation. In this case, set the last entry of est_dist to zero:

<BR><BR>
<align="left"><IMG SRC="../gifs/skew3.gif"></align>
<BR><BR>

Then, run calibration once again by clicking on <b>Calibration</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/skew4.gif" ></align>
<BR><BR>

Judging the result of calibration satisfactory, let us save the current calibration parameters by clicking on <b>Save</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/saving4.gif"></align>
<BR><BR>

In order to make a decision on the appropriate distortion model to use, it is sometimes very useful to visualize the effect of distortions on the pixel image, and the importance of the radial component versus the tangential component of distortion. For this purpose, run the script <B>visualize_distortions</B> at the matlab prompt (this function is not yet linked to any button in the GUI window). The three following images are then produced:

<BR><BR>
<center><IMG SRC="../gifs/dist_plot1.gif"></center>
<BR><BR>
<center><IMG SRC="../gifs/dist_plot2.gif"></center>
<BR><BR>
<center><IMG SRC="../gifs/dist_plot3.gif"></center>
<BR><BR>


The first figure shows the impact of the complete distortion model (radial + tangential) on each pixel of the image. Each arrow represents the effective displacement of a pixel induced by the lens distortion. Observe that points at the corners of the image are displaced by as much as 25 pixels. The second figure shows the impact of the tangential component of distortion. On this plot, the maximum induced displacement is 0.14 pixel (at the upper left corner of the image). Finally, the third figure shows the impact of the radial component of distortion.
This plot is very similar to the full distortion plot, showing the tangential component could very well be discarded in the complete distortion model. On the three figures, the cross indicates the center of the image, and the circle the location of the principal point.

<BR><BR>

Now, just as an exercise (not really recommended in practice), let us run an optimization without the lens
distortion model (by enforcing <b>kc = [0;0;0;0;0]</b>) and without aspect ratio (by enforcing both components of <B>fc</B> to be equal).  For that, set
the binary variables <b>est_dist</b> to <b>[0;0;0;0;0]</b> and <B>est_aspect_ratio</B> to <B>0</B> at the matlab
prompt:

<BR><BR>
<align="left"><IMG SRC="../gifs/no_dist1.gif"></align>
<BR><BR>

Then, run a new optimization by clicking on <b>Calibration</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/no_dist2.gif" ></align>
<BR><BR>

As expected, the distortion coefficient vector <B>kc</B> is now zero, and both components of the focal vector are equal (<B>fc(1)=fc(2)</B>).
In practice, this model for calibration is not recommended: for one thing, it makes little sense to estimate skew without aspect ratio. In general, unless required by a specific targeted application, it is recommended to always estimate the aspect ratio in the model (it is the 'easy part').
Regarding the distortion model, people often run optimization over a subset of the
distortion coefficients. For example, setting <b>est_dist</b> to
<b>[1;0;0;0]</b> keeps estimating the first distortion coefficient
<b>kc(1)</b> while enforcing the three others to zero. This model is also known as the second 
order symmetric radial distortion model. It is a very viable model, especially when using low distortion optical systems (expensive lenses), or when only a few images are used for calibration. Another very common distortion model is the 4th order symmetric radial distortion with no tangential component (<B>est_kc = [1;1;0;0]</B>). This model, used by <A href="ref.html">Zhang</A>, is justified by the fact that most lenses currently manufactured do not have imperfection in centering (for more information, visit this <a href="parameters.html">page</A>). This model could have very well been used in this present example, recalling from the previous three figures that the tangential component of the distortion model is significantly smaller that the radial component.<BR><BR>

Finally, let us run a calibration rejecting the aspect ratio <B>fc(2)/fc(1)</B>, the principal point
<b>cc</b>, the distortion coefficients <b>kc</b>, and the skew
coefficient <b>alpha_c</b> from the optimization estimation. For that
purpose, set the four binary variables <est_aspect_ration</B>, <b>center_optim</b>,
<b>est_dist</b> and <b>est_alpha</b> to the following values:

<BR><BR>
<align="left"><IMG SRC="../gifs/no_center1.gif"></align>
<BR><BR>

Generally, if the principal point is not estimated, the best guess for its location is the center of the image:

<BR><BR>
<align="left"><IMG SRC="../gifs/principal_point.gif"></align>
<BR><BR>

Then, run a new optimization by clicking on <b>Calibration</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/no_center2.gif"></align>
<BR><BR>

Observe that the principal point <b>cc</b> is still at the center of the image after optimization (since <B>center_optim=0</B>).
<BR><br>
Next, load the old calibration results previously saved in
<b>Calib_Results.mat</b> by clicking on <b>Load</b>:

<BR><BR>
<align="left"><IMG SRC="../gifs/loading.gif"></align>
<BR><BR>


</li>


<BR><BR> <font size=+2>Additional functions included in the
calibration toolbox:</font> <BR><BR>

<li>
<b><font size=+1>Computation of extrinsic parameters only:</font></b>
Download an additional image of the same calibration grid: <a href="Image_ext.tif">Image_ext.tif</a>.
<BR><BR>

<center><IMG SRC="../gifs/ext_comp0.gif"></center>

<BR><BR>
Notice that this image was not used in the main calibration procedure. The goal of this exercise is to compute the extrinsic parameters
attached to this image given the intrinsic camera parameters previously computed. <BR>
Click on <b>Comp. Extrinsic</b> in the <b>Camera calibration tool</b>, and successively enter the image name without extension (<b>Image_ext</b>),
the image type (<b>tif</b>), and extract the grid corners (following the same procedure as previously presented - remember: the first clicked point is the origin of the pattern reference frame). The extrinsic parameters (3D location of the
grid in the camera reference frame) is then computed. The main matlab window should look like: 
<BR><BR>

<align="left"><IMG SRC="../gifs/ext_comp1.gif"></align>


<BR><BR> The extrinsic parameters are encoded in the form of a
rotation matrix (<b>Rc_ext</B>) and a translation vector
(<b>Tc_ext</b>).  The rotation vector <b>omc_ext</b> is related to the
rotation matrix (<b>Rc_ext</B>) through the Rodrigues formula:
<b>Rc_ext = rodrigues(omc_ext)</b>.<BR> Let us give the exact
definition of the extrinsic parameters: <BR> Let <b>P</b> be a point
space of coordinate vector <b>XX = [X;Y;Z]</b> in the grid reference
frame <b>(O,X,Y,Z)</b> shown on the following figure: <BR><BR>

<center><IMG SRC="../gifs/ext_comp2.gif" ></center>

<BR><BR>
Let <b>XX<sub>c</sub> = [X<sub>c</sub>;Y<sub>c</sub>;Z<sub>c</sub>]</b> be the coordinate vector of <b>P</b> in the camera reference frame <b>(O<sub>c</sub>,X<sub>c</sub>,Y<sub>c</sub>,Z<sub>c</sub>)</b>. <BR>
Then <b>XX</b> and <b>XX<sub>c</sub></b> are related to each other through the following rigid motion equation: <BR><BR>

<center><b>XX<sub>c</sub> = Rc_ext * XX + Tc_ext</b></center>

<BR><BR>
In addition to the rigid motion transformation parameters, the coordinates of the grid points in the grid reference frame are also stored in the
matrix <b>X_ext</b>.
Observe that the variables <b>Rc_ext</B>, <b>Tc_ext</b>, <b>omc_ext</B> and <b>X_ext</b> are not automatically saved into any matlab file.

</li>

<BR><BR>

<li>
<b><font size=+1>Undistort images:</font></b> This function helps you generate the undistorted version of one or multiple images given pre-computed intrinsic camera parameters. <BR>
As an exercise, let us undistort <b>Image20.tif</b>. <BR>
Click on <b>Undistort image</b> in the <b>Camera calibration tool</b>.


<BR><BR>
<align="left"><IMG SRC="../gifs/undistort_comp0.gif"></align>
<BR><BR>

Enter 1 to select an individual image, and successively enter the image name without extension (<b>Image20</b>),
the image type (<b>tif</b>). The main matlab window should look like this:
<BR><BR>

<align="left"><IMG SRC="../gifs/undistort_comp1.gif"></align>

<BR><BR>
The initial image is stored in the matrix <b>I</b>, and displayed in figure 2:
<BR><BR>


<center><IMG SRC="../gifs/undistort_comp2.gif"></center>

<BR><BR>
The undistorted image is stored in the matrix <b>I2</b>, and displayed in figure 3:
<BR><BR>

<center><IMG SRC="../gifs/undistort_comp3.gif"></center>

<BR><BR>
The new undistorted image (<b>I2</b>) is also saved on disk under <b>Image20_rect.tif</b>.<BR>
<BR>
Let us now undistort the complete set of calibration images. Click on
<b>Undistort image</b>, and enter an empty argument to the first
question. All the calibration images are then undistorted and saved
onto disk under <b>Image_rect1.tif</b>, <b>Image_rect2.tif</b>, ...,
<b>Image_rect25.tif</b>:

<BR><BR>

<align="left"><IMG SRC="../gifs/undistort_comp4.gif"></align>

<BR><BR>


</li>



<li>
<b><font size=+1>Export calibration data to other formats
(Willson-Heikkilä and Zhang):</font></b> This function lets you
export the calibration data (extracted image corners + associated 3D
world coordinates) to Willson-Heikkilä or Zhang formats. This may be
useful for comparison purposes (if you want to run other people
calibration engines on the same data). This function may be used just
after the corner extraction phase.  Click on <b>Export calib data</b>
in the main toolbox window.

<BR><BR>
<align="left"><IMG SRC="../gifs/export1.gif"></align>
<BR><BR>

Enter <b>0</b> to select the data format used by Willson and Heikkilä, and enter the basename of the data files (<b>shot</b>). The calibration data of each image is then saved to individual files <b>shot1</b>, <b>shot2</b>,...,<b>shot25</b>:


<BR><BR>
<align="left"><IMG SRC="../gifs/export2.gif"></align>
<BR><BR>

Let us now export the data under Zhang's format. Click on  <b>Export calib data</b>, and enter <b>1</b> to select that new export format. Enter then two file basenames: one for the 3D rig coordinates (<b>Model</b>) and one for the image coordinates (<b>data</b>).
The program created then a set of text files (<b>Model1.txt</b>, <b>data1.txt</b>,...,<b>Model25.txt</b>, <b>data25.txt</b>) that can be read by Zhang's code.
After export, your matlab window should look like:


<BR><BR>
<align="left"><IMG SRC="../gifs/export3.gif"></align>
<BR><BR>


</li>

</ul>



<HR>

<P><FONT SIZE=+3><A HREF="../index.html#examples">Back to main calibration page</A></FONT>
</P>


</BODY>
</HTML>
